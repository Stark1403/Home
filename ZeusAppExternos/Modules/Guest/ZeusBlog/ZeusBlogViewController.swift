//
//  ZeusBlogViewController.swift
//  ZeusAppExternos
//
//  Created Alejandro Rivera on 26/09/23.
//  Copyright © 2023 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by UPAX Zeus
//

import UIKit
import WebKit
import ZeusUtils
import ZeusSessionInfo
import ZeusCoreDesignSystem

class ZeusBlogViewController: ZDSUDNViewController, ZeusBlogViewProtocol {
    
    var presenter: ZeusBlogPresenterProtocol?
    
    var webView: WKWebView?
    var containerView: UIView?
    var request: URLRequest?
    var url: URL?
    override func loadView()  {
        titleString = "Blog"
        super.loadView()
        webView = WKWebView()
        guard let webView = webView else{ return}
        webView.uiDelegate = self
        webView.navigationDelegate = self
        containerView = webView
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        navigationController?.setNavigationBarHidden(false, animated: false)
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        navigationController?.setNavigationBarHidden(true, animated: false)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .white
        headerColor = UIColor.zeusPrimaryColor
        guard let containerView = containerView else{ return}
        view.addSubview(containerView)
        containerView.translatesAutoresizingMaskIntoConstraints = false
        containerView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true
        containerView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true
        containerView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive = true
        containerView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor).isActive = true
        setLoader()
        presenter?.getURL()
    }
    
    override func backAction() {
//        if webView?.canGoBack ?? false{
//            webView?.goBack()
//        }
//        else{
            navigationController?.popViewController(animated: true)
//        }
    }
    
    func setURLToWebview(url: URL){
        let _request = URLRequest(url: url)
        request = _request
        request?.timeoutInterval = 30
        reloadWebView()
    }
}

extension ZeusBlogViewController: WKUIDelegate, WKNavigationDelegate{
    func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {
        setErrorScreen(errorType: .errorInternet)
    }
    func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
        setErrorScreen(errorType: .errorInternet)
    }
    func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
        setErrorScreen(errorType: .errorInternet)
    }
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        removerLoader()
    }
    func webView(_ webView: WKWebView, createWebViewWith configuration: WKWebViewConfiguration, for navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures) -> WKWebView? {
        if !(navigationAction.targetFrame?.isMainFrame ?? false){
            request = navigationAction.request
            reloadWebView()
        }
        return nil
    }
}

extension ZeusBlogViewController {
    func setURL(_ url: URL?) {
        guard let url = url else {return}
        let _request = URLRequest(url: url)
        request = _request
        webView?.addObserver(self, forKeyPath: "estimatedProgress", options: .new, context: nil);
        reloadWebView()
    }
    
    func setLoader(){
        showDSLoader()
    }
    
    func removerLoader(){
        DispatchQueue.main.asyncAfter(deadline: .now() + 2, execute: { [weak self] in
            self?.hideDSLoader()
        })
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == "estimatedProgress" {
            debugPrint(webView?.estimatedProgress ?? 0);
            webView?.estimatedProgress ?? 0.0 >= 0.5 ? removerLoader() : ()
            debugPrint(webView?.isLoading ?? false)
        }
    }
    
    func reloadInformation(){
        setLoader()
        presenter?.getURL()
    }
    
    @objc func reloadWebView(){
        setLoader()
        guard let request = request else {return}
        webView?.load(request)
    }
    
    func setErrorScreen(errorType: ZDSResultType){
        removerLoader()
        var view: ZDSResultAlertViewController?
        switch errorType {
        case .errorInternet:
            let delegateInternet = ErrorButtonHandler { [weak self] in
                guard let self = self else { return }
                self.dismiss(animated: false) {
                    self.reloadInformation()
                }
            } secondaryButtonAction: { [weak self] in
                guard let self = self else { return }
                self.dismiss(animated: true)
                self.backAction()
            } backButtonAction: { [weak self] in
                guard let self = self else { return }
                self.dismiss(animated: true)
                self.backAction()
            }
            
            view = ZDSResultAlertViewController(typeLottie: errorType,
                                                titulo: "¡Lo sentimos!",
                                                descripcion: "Tuvimos un problema de conexión, inténtalo más tarde",
                                                textoBoton: "Intentar nuevamente",
                                                textoSecundario: "Cancelar",
                                                color: UIColor.zeusPrimaryColor,
                                                isShowBackButton: true)
            view?.delegate = delegateInternet
        default:
            break
        }
        guard let view = view else { return }
        view.modalPresentationStyle = .fullScreen
        present(view, animated: true)
    }
}
