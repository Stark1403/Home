//
//  MyInformationViewInteractor.swift
//  ZeusAppExternos
//
//  Created Satori Tech 209 on 11/21/24.
//  Copyright Â© 2024 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by UPAX Zeus
//

import UIKit
import ZeusSessionInfo
import UPAXNetworking
import ZeusKeyManager

class MyInformationViewInteractor: MyInformationViewInteractorInputProtocol {
    
    weak var presenter: MyInformationViewInteractorOutputProtocol?
    private let networking = ZeusV2NetworkManager.shared.networking
    
    func getPrivateData(){
        guard let collaboratorId = SessionInfo.shared.user?.zeusId else { return }
        let pathParams = MyPrivateDataParams(collaboratorId: collaboratorId)
        let url = TalentoZeusConfiguration.baseURL.absoluteString + "/v2/colaborador/{collaboratorId}/personal-information"
        self.networking.call(url: url, method: .get ,pathParams: pathParams) { (_ result: Swift.Result<PersonalDataResponse, NetError>) in
            switch result {
            case .success(let result):
                guard let information = result.personalInformation else { return }
                self.presenter?.setPrivateData(data: information)
                self.placeBirthData(catalogId: "1")
                guard let data = result.personalInformation?.employment else { return }
                self.updateSessionInfo(data: data)
                break
            case .failure(let error):
                switch error {
                case .invalidResponse(_, let error):
                    self.presenter?.failAlert()
                    MyInformationEvents.shared.sendEvent(.screenError(idRequest: error?.requestID ?? ""))
                    break
                default:
                    self.presenter?.failAlert()
                    break
                }
                break
            }
        }
    }
    
    func placeBirthData(catalogId: String){
        let url = TalentoZeusConfiguration.baseCollaboratorURL.absoluteString + "/colaborador/\(0)/geographic-data"
        let pathParams = CatalogueParams(catalogueId: catalogId)
        self.networking.call(url: url, params: pathParams) { (_ result: Swift.Result<CatalogueResponse, NetError>) in
            switch result {
            case .success(let result):
                print(result)
                self.presenter?.setPlacesBirth(catalog: result.state)
                break
            case .failure(_):
                self.presenter?.failAlert()
                break
            }
        }
    }
    
    func sendVerification(number: String){
        guard let zeusId = SessionInfo.shared.user?.zeusId else {
            return }
        let url = TalentoZeusConfiguration.baseURL.absoluteString + "/verification"
        let params = VerificationRequest(collaborator_id: zeusId, phone_number: number)
        self.networking.call(url: url, method: .put, body: params) { (_ result: Swift.Result<SendOTPResponse, NetError>) in
            switch result {
            case .success(let result):
                self.presenter?.resultSendVerify(success: true)
                break
            case .failure(let error):
                if error.localizedDescription == "409"{
                    self.presenter?.resultSendVerify(success: false)
                }else{
                    self.presenter?.failAlert()
                }
                break
            }
        }
    }
    
    func updateData(data: PersonalInformationRequest) {
        guard let zeusId = SessionInfo.shared.user?.zeusId else {
            return }
        let url = TalentoZeusConfiguration.baseCollaboratorURL.absoluteString + "/colaborador/data/\(zeusId)"
        MyInformationEvents.shared.sendEvent(.requestInformation(data: "\(data)"))
        print("body: \(data)")
        self.networking.call(url: url, method: .put, body: data) { (_ result: Swift.Result<PersonalInformationResponse, NetError>) in
            switch result {
            case .success(let result):
                print(result)
                self.presenter?.responseUpdate()
                
                break
            case .failure(let error):
                switch error {
                case .invalidResponse(_, let error):
                    self.presenter?.failAlert()
                    MyInformationEvents.shared.sendEvent(.reasonInformation(idRequest: error?.requestID ?? ""))
                    
                    break
                default:
                    self.presenter?.failAlert()
                    break
                }
                break
            }
        }
    }
    
    func updateSessionInfo(data:EmploymentData){
        guard let user = SessionInfo.shared.user else{return}
        let newUser = User(zeusId: user.zeusId, employeeNumber: user.employeeNumber, name: data.name, lastName: data.paternal_surname, secondLastName: data.maternal_surname ?? user.secondLastName, photo: user.photo ?? "", job: (data.position ?? user.job) ?? "", area: data.area, mail: (data.email ?? user.mail) ?? "" , phoneNumber: (data.cell_phone_number ?? user.phoneNumber) ?? "", countryCode: user.countryCode, leaderZeusId: user.leaderZeusId, udnId: user.udnId,companyIdentifier: data.identifier ?? user.companyIdentifier)
        
        SessionInfoQueries.shared.updateUserInfo(user: newUser)
    }
}




// MARK: - Zone
struct WorkZoneEntity: Codable {
    let id: Int
    let name: String
    let latitude, longitude: String
    let radio: Double
}

struct UpdateParams: UNCodable {
    let collaboratorId: String
    
    private enum CodingKeys: String, CodingKey {
        case collaboratorId = "collaboratorId"
    }
    
    public func getUNCodingKeys() -> [UNCodingKey] {
        return [
            
            .init(property: "collaboratorId", serializedName: "collaboratorId",requiresEncryption: false)
        ]
    }
}

struct CatalogueParams: UNCodable {
    let catalogueId: String
    
    private enum CodingKeys: String, CodingKey {
        case catalogueId = "id-catalogue"
    }
    
    public func getUNCodingKeys() -> [UNCodingKey] {
        return [
            
            .init(property: "catalogueId", serializedName: "id-catalogue",requiresEncryption: false)
        ]
    }
}

struct CatalogueResponse: UNCodable {
    let state: [Catalogue]
    
}

struct Catalogue: UNCodable {
    let id: Int?
    let name: String?
    let description: String?
    
}

struct PersonalInformationRequest: UNCodable {
    var correo: String?
    var fechaNacimiento: String?
    var lugarNacimiento: Int?
    var unidadMedica: String?
    
    private enum CodingKeys: String, CodingKey {
        case correo = "correo"
        case fechaNacimiento = "fecha_nacimiento"
        case lugarNacimiento = "lugar_nacimiento"
        case unidadMedica = "unidad_medica"
    }
    
    public func getUNCodingKeys() -> [UNCodingKey] {
        return [
            .init(property: "correo", serializedName: "correo",requiresEncryption: false),
            .init(property: "fechaNacimiento", serializedName: "fecha_nacimiento",requiresEncryption: false),
            .init(property: "lugarNacimiento", serializedName: "lugar_nacimiento",requiresEncryption: false),
            .init(property: "unidadMedica", serializedName: "unidad_medica",requiresEncryption: false)
        ]
    }
}

public struct PersonalInformationResponse: Codable {
    var message: String?
}
