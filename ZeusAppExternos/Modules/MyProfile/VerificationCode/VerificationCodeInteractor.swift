//
//  VerificationCodeInteractor.swift
//  ZeusAppExternos
//
//  Created Satori Tech 209 on 11/21/24.
//  Copyright Â© 2024 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by UPAX Zeus
//

import UIKit
import ZeusSessionInfo
import UPAXNetworking
import ZeusKeyManager

class VerificationCodeInteractor: VerificationCodeInteractorInputProtocol {
    weak var presenter: VerificationCodeInteractorOutputProtocol?
    private let networking = ZeusV2NetworkManager.shared.networking
    
    func sendVerification(number: String){
        guard let zeusId = SessionInfo.shared.user?.zeusId else {
            return }
        let url = TalentoZeusConfiguration.baseURL.absoluteString + "/verification"
        let params = VerificationRequest(collaborator_id: zeusId, phone_number: number)
        self.networking.call(url: url, method: .put, body: params) { (_ result: Swift.Result<SendOTPResponse, NetError>) in
            switch result {
            case .success(let result):
                print(result)
                self.presenter?.resultSendVerify(success: true)
                break
            case .failure(let error):
                if error.localizedDescription == "409"{
                    self.presenter?.resultSendVerify(success: false)
                }else{
                    self.presenter?.failAlert()
                }
                break
            }
        }
    }
    
    func verificationCode(code: String){
        guard let zeusId = SessionInfo.shared.user?.zeusId else {
            return }
        let url = TalentoZeusConfiguration.baseURL.absoluteString + "/verification/code"
        let params = VerifyPhoneRequest(username: zeusId, codeVerification: code)
        self.networking.call(url: url, method: .post, body: params) { (_ result: Swift.Result<VerifyPhoneResponse, NetError>) in
            switch result {
            case .success(let result):
                self.presenter?.resultVerifyCode(success: true)
                break
            case .failure(let error):
                self.presenter?.resultVerifyCode(success: false)
                break
            }
        }
    }
    
}
struct VerificationRequest: UNCodable {
    let collaborator_id: String?
    let phone_number: String?
    
    public func getUNCodingKeys() -> [UNCodingKey] {
        return [
            .init(property: "collaborator_id", requiresEncryption: true),
            .init(property: "phone_number", requiresEncryption: true)
        ]
    }
}
struct SendOTPResponse: UNCodable {
    let message: String
    
    private enum CodingKeys: String, CodingKey {
        case message = "message"
    }
    
    public func getUNCodingKeys() -> [UNCodingKey] {
        return [
            .init(property: "message", serializedName: "message", requiresEncryption: false)
        ]
    }
}

struct VerifyPhoneRequest: UNCodable {
    let username: String
    let codeVerification: String
    
    private enum CodingKeys: String, CodingKey {
        case username = "username"
        case codeVerification = "code_verification"
    }
    
    public func getUNCodingKeys() -> [UNCodingKey] {
        return [
            .init(property: "username", serializedName: "username", requiresEncryption: true),
            .init(property: "codeVerification", serializedName: "code_verification", requiresEncryption: true)
        ]
    }
}

struct VerifyPhoneResponse: UNCodable {
    let message: String
    
    private enum CodingKeys: String, CodingKey {
        case message = "message"
    }
    
    public func getUNCodingKeys() -> [UNCodingKey] {
        return [
            .init(property: "message", serializedName: "message", requiresEncryption: false)
        ]
    }
}
